---require implementation in pure Lua for a sandbox environment, with support for globs and full directory tree search.
--Licensed under the MIT license, whatever that is.
--locals for fast access

local i=1

local fs_list=fs.list
local fs_isDir=fs.isDir
local fs_exists=fs.exists
local string=string
vars={} --to allow edition
vars.loaded={}
function loadFile(path,_reload) --@_reload forces reload
	if (vars.loaded[path]==nil) or _reload then
		local fnFile, err = loadfile( path )
		if not fnFile then error('load:'..'path=:'..path..'| '..(err or 'nil'),2) end
		vars.loaded[path]=fnFile
	end
	return vars.loaded[path]
end

--helpers for @loadPerGlob

---WARNING: for compatibility with Lua ?, ? was replaced by # in globs; taken from https://github.com/davidm/lua-glob-pattern , by davidm
--only needed for filename conversion, slashes are dealt with directly for iteration purposes.
local function globtopattern(g)

  local p = "^"  -- pattern being built
  local i = 0    -- index in g
  local c        -- char at index i in g.

  
    -- unescape glob char
  local function unescape()
    if c == '\\' then
      i = i + 1; c = string.sub(g,i,i)
      if c == '' then
        p = '[^]'
        return false
      end
    end
    return true
  end

  -- escape pattern char
  local function escape(c)
    return c:match("^%w$") and c or '%' .. c
  end
  -- Convert tokens at end of charset.
  local function charset_end()
    while 1 do
      if c == '' then
        p = '[^]'
        return false
      elseif c == ']' then
        p = p .. ']'
        break
      else
        if not unescape() then break end
        local c1 = c
        i = i + 1; c = string.sub(g,i,i)
        if c == '' then
          p = '[^]'
          return false
        elseif c == '-' then
          i = i + 1; c = string.sub(g,i,i)
          if c == '' then
            p = '[^]'
            return false
          elseif c == ']' then
            p = p .. escape(c1) .. '%-]'
            break
          else
            if not unescape() then break end
            p = p .. escape(c1) .. '-' .. escape(c)
          end
        elseif c == ']' then
          p = p .. escape(c1) .. ']'
          break
        else
          p = p .. escape(c1)
          i = i - 1 -- put back
        end
      end
      i = i + 1; c = string.sub(g,i,i)
    end
    return true
  end

  -- Convert tokens in charset.
  local function charset()
    i = i + 1; c = string.sub(g,i,i)
    if c == '' or c == ']' then
      p = '[^]'
      return false
    elseif c == '^' or c == '!' then
      i = i + 1; c = string.sub(g,i,i)
      if c == ']' then
        -- ignored
      else
        p = p .. '[^'
        if not charset_end() then return false end
      end
    else
      p = p .. '['
      if not charset_end() then return false end
    end
    return true
  end
 --Convert tokens.
  while 1 do
	i = i + 1; c = string.sub(g,i,i)
    if c == '' then
      p = p .. '$'
      break
    elseif c == '#' then --?->#
      p = p .. '.'
    elseif c == '*' then
      p = p .. '.*'
    elseif c == '[' then
      if not charset() then break end
    elseif c == '\\' then
      i = i + 1; c = string.sub(g,i,i)
      if c == '' then
        p = p .. '\\$'
        break
      end
      p = p .. escape(c)
    else
      p = p .. escape(c)
    end
  end
  return p
end

---turns a glob into a table structure proper for iterPatterns.
local function compact(g)
	
	local nl={}
	local s1
	local n=0
	
	-- print(g)
	for c in string.gmatch(g,'[\\/]*([^/\\]+)[\\/]*') do
		-- print(c)
		if c:match('^[%w%s%.]*$') then
			s1=s1 and s1..'/'..c or c
		else
			n=n+1
			nl[n]={s1,globtopattern(c)}
			s1=nil
		end
	end
	
	if s1 then
		-- print('s1=',s1)
		if n==0 then
			-- print('n==0')
			n=n+1
			nl[n]={s1}
		else
			nl[n][3]=s1
		end
	end
	return nl
end

---iterator creator over valid paths defined by a table with the structure: {t1,...,tn}, where ti is:
--for i<n: {dir,pat} - dir is the directory where to look for names matching the pattern pat
--for i=n: {dir,pat,ending} -same but will combine the name (after successful match with pat) with the optional ending (can be nil) and check the resulting path
--e.g., g={{'APIS','*'},{nil,'A'},{'B/C','#','aq/qwerty'}} will search in all subfolders of APIS for subfolders named A, and in each of those for a folder B
--containing a folder C, and for all one-lettered folders in that folder for a folder aq containing a  folder/file named qwerty.
local function iterPatterns(l)
	local n=#l
	-- print('n',n)
	if n==0 then return function () return  end end
	if n==1 and not l[1][2] and fs_exists(l[1][1]) then
		local done=false
		return function ()
				if not done then
					done=true
					return l[1][1]
				else
					return
				end
			end
	end
	-- pprint(l)
	-- read()
	local dir=l[1][1]
	-- print('dir',dir)
	local index={0}
	local ts
	ts={{dir,fs_isDir(dir) and fs_list(dir) or {}}}
	-- read()
	-- pprint(ts)
	-- read()
	local level=1
	local t_dir
	local _
	return function()
		repeat
			index[level]=index[level]+1
			name=ts[level][2][index[level]]
			-- print('index:')
			-- pprint(index)
			-- print('level:',level)
			-- print('name:',name)
			-- print('dir:',dir)
			-- print('look:',l[level][2])
			-- print('match:',name and l[level] and l[level][2] and string.match(name,l[level][2]))
			-- read()
			if name==nil then
					-- print('name is nil')
					index[level]=nil
					level=level-1
					if level==0 then return end
					dir=ts[level][1]
			else
				if string.match(name,l[level][2]) then
					t_dir=dir..'/'..name
					-- print('t_dir:',t_dir)
					-- print('matches')
					-- print('level:',level)
					--pprint(l)
					-- read()
					if level==n then
						-- print('last level')
						_=l[level][3]
						if _ then
							t_dir=t_dir..'/'.._
							if fs_exists(t_dir) then
								path=t_dir
								break
							end
						else
							path=t_dir
							break
						end
					elseif fs_isDir(t_dir) then
						-- print('a dir!')
						level=level+1
						_=l[level][1]
						if _ then
							t_dir=t_dir..'/'.._
							if fs_exists(t_dir) then
								dir=t_dir
								ts[level]={dir,fs_list(dir)}
								index[level]=0
							else
								level=level-1
							end
						else
							dir=t_dir
							ts[level]={dir,fs_list(dir)}
							index[level]=0
						end
					end
				end
			end
		until false
		return path, index
	end
end

---iterator creator, over the valid paths defined by glob @g, e.g */filenumber?to
-- see the unix part of the table at http://en.wikipedia.org/wiki/Glob_(programming) .
--@treturn string path to matching of the dir
--@usage
--for path in search.iterGlob('*/stuff?/a*') do
--	print(path)
--end
--APIS/stuff1/a.lua
--var/stuff2/a.var
function iterGlob(g)
	return iterPatterns(compact(g))
end

--iterator over glob @g with ? replaced by @s
searchGlob = function (g,s)
	
	g=string.gsub(g,'%?',s)
	
	-- print(g)
	local iter=iterGlob(g)
	
	local path
	return function ()
		repeat
			path=iter()
			if path then
				if not fs_isDir(path) then	
					return path
				end
			else
				break
			end
		until false
	end
end


--'helpers' for @loadFullSearch

function iterFiles(dir,depth)
	dir=dir or ''
	local index={0}
	local dir_index={0}
	local ts={{dir,fs_list(dir),{}}}
	local level=1
	local t_dir
	return function()
		repeat
			index[level]=index[level]+1
			name=ts[level][2][index[level]]
			if name==nil then
				if (not ts[level][4]) and ts[level][3][1] then
					ts[level][4]=true
					ts[level][2],ts[level][3]=ts[level][3],ts[level][2]
					index[level]=0
				else
					level=level-1
					if level==0 then return end
					dir=ts[level][1]
				end
			else
				t_dir=ts[level][1]..'/'..name
				if fs_isDir(t_dir) then
					if ts[level][4] then
						if depth~=level then
							level=level+1
							dir=t_dir
							ts[level]={dir,fs_list(dir),{}}
							index[level]=0
							dir_index[level]=0
						else
						end
					else
						dir_index[level]=dir_index[level]+1
						ts[level][3][dir_index[level]]=name
					end
				else
					break
				end
			end
		until false
		return dir..'/'..name
	end
end
function getNameExpansion(s) --returns name and expansion from a filepath @s; special cases: ''->'',nil; '.'-> '','';
	--s string = filename
	--returns: name, expansion
	--Example
	--print(getNameExpansion('filename.lua.kl'))
	--filename
	--lua.kl
	local _,_,name,expa=string.find(s, '([^%./\\]*)%.(.*)$')
	return name or s,expa
end
function getDir(s) --returns directory from filepath @s
	return string.match(s,'^(.*)/') or '/'
end

--iterator over directory @p searching for @p...@s
--
searchTree = function (p,s)
	if not p:match('%?') and fs_isDir(p) then
		if p=='/' then p='' end
		local iter=iterFiles(p)
		local path
		local count=os.clock()
		return function ()
			repeat
				print(path)
				if os.clock()-count>0.05 then --I have an huge filesystem
					sleep(0)
					count=os.clock()
				end
				path=iter()
				if path then
					if string.match(path,s..'$') and not string.match(path,'[^/]'..s..'$') then
						return path
					end
				else
					break
				end
			until false
		end
	else
		return function() end
	end
end


--add your iterators here; must take (p,s) where p is where to search and s is what to search for.
vars.finders={searchGlob,searchTree}
vars.paths='?;?.lua;?/init.lua;APIS/?;APIS/?.lua;APIS/?/init.lua;packages/?;packages/?.lua;packages/?/init.lua;packages/?/?;packages/?/?.lua;/'

--helper vars for lua_requirer; other requirers may index theirs vars in loadreq.vars
vars.lua_requirer={
required={}, --to unrequire filepath s do require[s]=nil
required_envs={}, --to prevent garbage collection
requiring={}, --to throw error in case of recursive requiring;
}

--[[lua_requirer(path,cenv,env,renv,rerun,args)
if the rerun flag is true, reloads the file even if it done it before
only requires files with no extension
if the file has been loaded already returns previous value;
if the file is being loaded returns nil, error_message
else:
loads file in @path;
sets it's env to @env, default {} with metatable with __index set to @renv, default _G;
calls the function with unpack(@args) and returns and saves either
	the function return
	a shallow copy of the functions environment
]]

function lua_requirer(path,cenv,env,renv,rerun,args)
	local err_prefix='lua_requirer:'
	local vars=vars.lua_requirer
	local _,ext=getNameExpansion(path)
	if not (ext=='' or ext=='lua') then
		return nil, err_prefix..'wrong extension:'..ext
	end
	
	if vars.requiring[path] then
		return nil, err_prefix..'file is being loaded'
	end
	if not rerun and vars.required[path] then
		return vars.required[path]
	end
	
	local f,e=loadfile(path)
	if not f then
		return nil,err_prefix..'loadfile:'..e
	end
	env=env or {}
	env.FILE_PATH=path
	vars.required_envs[path]=env
	setfenv(f,env)
	renv=renv or _G
	setmetatable(env,{__index=renv})
	vars.requiring[path]=true
	local r=f(args and unpack(args)) --raises useful error/traceback, no need to tamper with
	vars.requiring[path]=nil
	if r then
		vars.required[path]=r
		return r
	else
		local t={}
		for i,v in pairs(env) do t[i]=v end
		vars.required[path]=t
		return t
	end
end

--replacement for os_loadAPI that keeps APIS to the caller's env
old_os_loadAPI=os.loadAPI
new_os_loadAPI=function(p)
	local cenv=getfenv(2)
	local r,e=loadreq.lua_requirer(p,cenv)
	if r then
		local name=getNameExpansion(p)
		protect(r)
		cenv[p]=r
	else
		error('os.loadAPI(loadreq version):'..e..'\n'..'path='..p,2)
	end
end

--[[add your requirers here;
each must 
take as arguments (path,cenv,...) where
	path is the path to required file
	cenv is the environment of the caller of @require
	... are extra arguments passed to @require
return
	one value to be returned by @require
	false|nil, error_message in case of failure
]]
vars.requirers={lua_requirer}

function sufix(s)
	return string.gsub('@/?;@/?.lua;@/?/init.lua;@/?/?.lua;@/?/?;@','@',s)
end

--[[require(s,paths,...)
-acquires @paths variable;
	@paths is a string, made of globs separated by ';'
	globs can be normal paths or contain special characters ('?' and others ('?' was replaced by '#') as described here: see the unix part of the table at http://en.wikipedia.org/wiki/Glob_(programming))
defaults to:
	0-arg @paths
		Example:
		myAPI=require('myFolder2.myAPI','myFolder/?.lua') 
	1-REQUIRE_PATH in the caller's path, if existent
		Example:
		REQUIRE_PATH='myFolder/?.lua'
		myAPI=require'myFolder2.myAPI' 
	2-directory named PACKAGE_NAME in FILE_PATH, if defined in the caller's environment
	with sufixes appended by @sufix and concatenated with @vars.paths.
	FILE_PATH is set, for instance, by lua_loader in the files it loads.
		Example:
		(FILE_PATH='myFolder/myFolder3/myFolder/runningFile')
		PACKAGE_NAME='myFolder'
		myAPI=require'myAPI' --@paths is 'myFolder/?;myFolder/?.lua;myFolder/?/init.lua;myFolder/?/?.lua;myFolder/?/?;myFolder'
	3-directory of FILE_PATH, if defined
	with sufixes appended by @sufix and concatenated with @vars.paths.
		Example:
		(FILE_PATH='myFolder/runningFile')
		myAPI=require'myAPI' --@paths is 'myFolder/?;myFolder/?.lua;myFolder/?/init.lua;myFolder/?/?.lua;myFolder/?/?;myFolder'
	4-@vars.paths as set in loadreq.vars.path
-replaces '.' in @s by '/' and '..' by '.'
--for all globs in @paths
 -	for all iterators in vars.finders iterates over the paths returned;
	default iterators:
		searchGlob: replaces '?' in the glob by @s paths and iterates over the filepaths that match the glob
		searchTree: only for globs that are directory paths: paths that are in the directory tree of glob		
-for the first valid path, calls the loaders sequentially until one succeds, 
in which case it returns the first value that the loader returns, else if it returns nil,e accumulates e as an error message
else if all loaders fail errors immediatly, printing all error messages
-in case of failure finding the path, errors with useful info
]]

function require(s,paths,...)
	local caller_env=getfenv(2)
	if paths then
	elseif caller_env.REQUIRE_PATH then
		paths=caller_env.REQUIRE_PATH
	elseif caller_env.PACKAGE_NAME and caller_env.FILE_PATH then
		paths=sufix(string.match(caller_env.FILE_PATH,'^(.*'..caller_env.PACKAGE_NAME..')'))..';'..vars.paths
	elseif	caller_env.FILE_PATH then
		paths=sufix(getDir(caller_env.FILE_PATH))..';'..vars.paths
	else
		paths=vars.paths
	end
	
	--replace . by / and .. by . 
	s=string.gsub(s,'([^%.])%.([^%.])','%1/%2') 
	s=string.gsub(s,'^%.([^%.])','/%1')
	s=string.gsub(s,'%.%.','.')
	
	-- print(s)
	local err={}
	for _,finder in ipairs(vars.finders) do

		for search_path in string.gmatch(paths,';?([^;]+);?') do
			
			-- print(search_path)
			for path in finder(search_path,s) do
				
				table.insert(err,'path='..path)
				
				-- print(path)
				for __,requirer in ipairs(vars.requirers) do
					
					-- print(path)
					local r,e=requirer(path,caller_env,...)
					if r then
						return r
					else
						
						table.insert(err,e)
					end
					
				end
				
				error(table.concat(err,'\n'),2) --this path can't be loaded, and yet it is a similar file? consider specifying path more or fixing bugs!
				
			end
		end
	end
	
	table.insert(err,'require:file not found:'..s..'\npaths='..paths..'\ncaller path='..(caller_env.FILE_PATH or 'not available'))
	
	error(table.concat(err,'\n'),2)
	
end

---runs filepath path with args ... using the same rules as @require for determining the globs to uses
--e.g.
--[[
os.loadAPI('APIS/loadreq')
loadreq.vars.paths=loadreq.vars.paths..';myFolder'
--or
REQUIRE_PATH='myFolder'
--ect
loadreq.run_lua('subFolder/subsubFolder/myFile.lua',arg1,arg2,...)
]]
function run_lua(path,...)
	if type(path)~='string' then error('loadreq.run_lua:not a string:',path) end
	path=path:gsub('%.','..')
	path=path:gsub('%/','.')
	return require(path,nil,nil,nil,true,{...})
end


--utilities
function set_env(f,env,renv)--sets @f 's env to @env (default new table {}) and the metatable of @env to {__index=@renv (default _G)}
	local env = env or {}
	local renv = renv or _G
	setmetatable( env, { __index = renv } )
	setfenv( f, env )
end

function str(s,env,renv) --loads string @s setting it's env to @env (default is the caler's env) and the metatable of @env to {__index=@renv}
	local f, err = loadstring( s )
	if not f then error( 'loadreq.str:'..(err or 'nil') ,2) end
	set_env(f,env or getfenv(2),renv)
	return f
end

function file(p,env,renv) --(re)loads file in path @p setting it's env to @env and the metatable of @env to {__index=@renv}
	f=loadfile(p)
	if not f then error('file',2) end
	env=env or {}
	env.FILE_PATH=p
	set_env(f,env,renv)
	return f
end

function run(p,args,env,renv)--runs file in path @p and unpacks @args to get arguments for the file; sets it's env to @env (default is the caler's env) and the metatable of @env to {__index=@renv}
	f=file(p,env,renv)
	args=args or {}
	return f(unpack(args))
end

--protection utilities; these are meant more as a warning than OS-grade protection
vars.bProtected=true
local function protected_access(t,k,v)
	if vars.bProtected then
		error( "Attempt to write to protected" )
	else
		rawset( t, k, v )
	end
end
function protect(_t)--shallow protection for tables (slows down access to the tables themselves, not to their values, e.g. local t.a=protected_table.a print(a) should do the trick)
	local meta = getmetatable( _t )
	if meta == "Protected" then
		-- already hard protected
		return
	end
	if meta then
		meta.__newindex = protected_access
	else
		setmetatable( _t, {__newindex = protected_access} )
	end
end
function unprotect(_t)--removes the shallow protection
	local meta = getmetatable( _t )
	if not meta then
		return
	end
	vars.bProtected=false
	meta.__newindex=nil
	vars.bProtected=true
end

function permaProtect(_t) --same as the os.loadAPI does
	local meta = getmetatable( _t )
	if meta == "Protected" then
		-- already hard protected
		return
	end
	setmetatable( _t, {
		__newindex = function( t, k, v )
			if bProtected then
				error( "Attempt to write to protected" )
			else
				rawset( t, k, v )
			end
		end,
		__metatable = 'Protected',
	} )
end

--module utilities

function module(M) --copies env of the caller to table @M (default {}) and returns it
	M=M or {}
	for i,v in getfenv(2) do
		M[i]=v
	end
	return M
end


env=getfenv() --this keeps the env from being collected to garbage
