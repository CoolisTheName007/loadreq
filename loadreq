---require implementation in pure Lua for a sandbox environment, with support for globs and full directory tree search.
--Licensed under the MIT license, whatever that is.
--locals for fast access
local fs_list=fs.list
local fs_isDir=fs.isDir
local fs_exists=fs.exists
local string=string
vars={} --to circumvent os.loadAPI
vars.loaded={}
function loadFile(path,_reload) --@_reload forces reload
	if (vars.loaded[path]==nil) or _reload then
		local fnFile, err = loadfile( path )
		if not fnFile then error('load:'..'path=:'..path..'| '..(err or 'nil'),2) end
		vars.loaded[path]=fnFile
	end
	return vars.loaded[path]
end

--helpers for @loadPerGlob

---WARNING: for compatibility with Lua ?, ? was replaced by # in globs; taken from https://github.com/davidm/lua-glob-pattern , by davidm
--only needed for filename conversion, slashes are dealt with directly for iteration purposes.
local function globtopattern(g)

  local p = "^"  -- pattern being built
  local i = 0    -- index in g
  local c        -- char at index i in g.

  
    -- unescape glob char
  local function unescape()
    if c == '\\' then
      i = i + 1; c = string.sub(g,i,i)
      if c == '' then
        p = '[^]'
        return false
      end
    end
    return true
  end

  -- escape pattern char
  local function escape(c)
    return c:match("^%w$") and c or '%' .. c
  end
  -- Convert tokens at end of charset.
  local function charset_end()
    while 1 do
      if c == '' then
        p = '[^]'
        return false
      elseif c == ']' then
        p = p .. ']'
        break
      else
        if not unescape() then break end
        local c1 = c
        i = i + 1; c = string.sub(g,i,i)
        if c == '' then
          p = '[^]'
          return false
        elseif c == '-' then
          i = i + 1; c = string.sub(g,i,i)
          if c == '' then
            p = '[^]'
            return false
          elseif c == ']' then
            p = p .. escape(c1) .. '%-]'
            break
          else
            if not unescape() then break end
            p = p .. escape(c1) .. '-' .. escape(c)
          end
        elseif c == ']' then
          p = p .. escape(c1) .. ']'
          break
        else
          p = p .. escape(c1)
          i = i - 1 -- put back
        end
      end
      i = i + 1; c = string.sub(g,i,i)
    end
    return true
  end

  -- Convert tokens in charset.
  local function charset()
    i = i + 1; c = string.sub(g,i,i)
    if c == '' or c == ']' then
      p = '[^]'
      return false
    elseif c == '^' or c == '!' then
      i = i + 1; c = string.sub(g,i,i)
      if c == ']' then
        -- ignored
      else
        p = p .. '[^'
        if not charset_end() then return false end
      end
    else
      p = p .. '['
      if not charset_end() then return false end
    end
    return true
  end
 --Convert tokens.
  while 1 do
	i = i + 1; c = string.sub(g,i,i)
    if c == '' then
      p = p .. '$'
      break
    elseif c == '#' then --?->#
      p = p .. '.'
    elseif c == '*' then
      p = p .. '.*'
    elseif c == '[' then
      if not charset() then break end
    elseif c == '\\' then
      i = i + 1; c = string.sub(g,i,i)
      if c == '' then
        p = p .. '\\$'
        break
      end
      p = p .. escape(c)
    else
      p = p .. escape(c)
    end
  end
  return p
end

---turns a glob into a table structure proper for iterPatterns.
local function compact(g)
	local nl={}
	local s1
	local n=0
	for c in string.gmatch(g,'[\\/]*([^/\\]*)[\\/]*') do
		-- print(c)
		if c:match('^[%w%s%.]*$') then
			s1=s1 and s1..'/'..c or c
		else
			n=n+1
			nl[n]={s1,globtopattern(c)}
			s1=nil
		end
	end
	if s1 then
		-- print('s1=',s1)
		if n==0 then
			-- print('n==0')
			n=n+1
			nl[n]={s1}
		else
			nl[n][3]=s1
		end
	end
	-- for i,v in pairs(nl) do
		-- print(i)
		-- print(v[1])
		-- print(v[2])
	-- end
	-- read()
	return nl
end

---iterator creator over valid paths defined by a table with the structure: {t1,...,tn}, where ti is:
--for i<n: {dir,pat} - dir is the directory where to look for names matching the pattern pat
--for i=n: {dir,pat,ending} -same but will combine the name (after successful match with pat) with the optional ending (can be nil) and check the resulting path
--e.g., g={{'APIS','*'},{nil,'A'},{'B/C','#','aq/qwerty'}} will search in all subfolders of APIS for subfolders named A, and in each of those for a folder B
--containing a folder C, and for all one-lettered folders in that folder for a folder aq containing a  folder/file named qwerty.
local function iterPatterns(l)
	local n=#l
	-- print('n',n)
	if n==0 then return function () return  end end
	if n==1 and not l[1][2] and fs_exists(l[1][1]) then
		local done=false
		return function ()
				if not done then
					done=true
					return l[1][1]
				else
					return
				end
			end
	end
	-- pprint(l)
	-- read()
	local dir=l[1][1]
	-- print('dir',dir)
	local index={0}
	local ts
	ts={{dir,fs_isDir(dir) and fs_list(dir) or {}}}
	-- read()
	-- pprint(ts)
	-- read()
	local level=1
	local t_dir
	local _
	return function()
		repeat
			index[level]=index[level]+1
			name=ts[level][2][index[level]]
			-- print('index:')
			-- pprint(index)
			-- print('level:',level)
			-- print('name:',name)
			-- print('dir:',dir)
			-- print('look:',l[level][2])
			-- print('match:',name and l[level] and l[level][2] and string.match(name,l[level][2]))
			-- read()
			if name==nil then
					-- print('name is nil')
					index[level]=nil
					level=level-1
					if level==0 then return end
					dir=ts[level][1]
			else
				if string.match(name,l[level][2]) then
					t_dir=dir..'/'..name
					-- print('t_dir:',t_dir)
					-- print('matches')
					-- print('level:',level)
					--pprint(l)
					-- read()
					if level==n then
						-- print('last level')
						_=l[level][3]
						if _ then
							t_dir=t_dir..'/'.._
							if fs_exists(t_dir) then
								path=t_dir
								break
							end
						else
							path=t_dir
							break
						end
					elseif fs_isDir(t_dir) then
						-- print('a dir!')
						level=level+1
						_=l[level][1]
						if _ then
							t_dir=t_dir..'/'.._
							if fs_exists(t_dir) then
								dir=t_dir
								ts[level]={dir,fs_list(dir)}
								index[level]=0
							else
								level=level-1
							end
						else
							dir=t_dir
							ts[level]={dir,fs_list(dir)}
							index[level]=0
						end
					end
				end
			end
		until false
		return path, index
	end
end

---iterator creator, over the valid paths defined by glob @g, e.g */filenumber?to
-- see the unix part of the table at http://en.wikipedia.org/wiki/Glob_(programming) .
--@treturn string path to matching of the dir
--@usage
--for path in search.iterGlob('*/stuff?/a*') do
--	print(path)
--end
--APIS/stuff1/a.lua
--var/stuff2/a.var
function iterGlob(g)
	return iterPatterns(compact(g))
end

searchGlob = function (g,s)
	g=string.gsub(g,'%?',s)
	--print(g)
	
	local iter=iterGlob(g)
	local path
	return function ()
		repeat
			path=iter()
			if path then
				if not fs_isDir(path) then
					return path
				end
			else
				break
			end
		until false
	end
end


--'helpers' for @loadFullSearch

function iterFiles(dir,depth)
	dir=dir or ''
	local index={0}
	local dir_index={0}
	local ts={{dir,fs_list(dir),{}}}
	local level=1
	local t_dir
	return function()
		repeat
			index[level]=index[level]+1
			name=ts[level][2][index[level]]
			if name==nil then
				if (not ts[level][4]) and ts[level][3][1] then
					ts[level][4]=true
					ts[level][2],ts[level][3]=ts[level][3],ts[level][2]
					index[level]=0
				else
					level=level-1
					if level==0 then return end
					dir=ts[level][1]
				end
			else
				t_dir=ts[level][1]..'/'..name
				if fs_isDir(t_dir) then
					if ts[level][4] then
						if depth~=level then
							level=level+1
							dir=t_dir
							ts[level]={dir,fs_list(dir),{}}
							index[level]=0
							dir_index[level]=0
						else
						end
					else
						dir_index[level]=dir_index[level]+1
						ts[level][3][dir_index[level]]=name
					end
				else
					break
				end
			end
		until false
		return dir..'/'..name
	end
end
function getNameExpansion(s) --returns name and expansion from a filepath @s
	--s string = filename
	--returns: name, expansion
	--Example
	--print(getNameExpansion('filename.lua.kl'))
	--filename
	--lua.kl
	local _,_,name,expa=string.find(s, '([^%./\\]*)%.(.*)$')
	return name or s,expa
end
function getDir(s) --returns directory from filepath @s
	return string.match(s,'^(.*)/') or '/'
end

searchTree = function (p,s)
	if fs_isDir(p) then
		if p=='/' then p='' end
		local iter=iterFiles(p)
		local path
		return function ()
			repeat
				path=iter()
				if path then
					if string.match(path,s..'$') and not string.match(path,'[^/]'..s..'$') then
						return path
					end
				else
					break
				end
			until false
		end
	else
		return function() end
	end
end



vars.finders={searchGlob,searchTree}
vars.paths='?;?.lua;?/init.lua;APIS/?;APIS/?.lua;APIS/?/init.lua;packages/?;packages/?.lua;packages/?/init.lua;packages/?/?;packages/?/?.lua;/'

vars.required={} --to unrequire filepath s do require[s]=nil
vars.required_envs={} --garbage collection deletes loose envs?
vars.requiring={} --to throw error in case of recursion
---require, exactly like the Lua one + some extras (comments above this deliberatedly over confident statement are welcome!)
--	if upon call the loaded function does not return, it returns a table with all public values of the function environment 
--@s e.g 'folder.other_folder.file' (no extensions such as .lua); each point is later replaced with '/'
--	if @s has been loaded by require previously, the value returned before is returned again
--  if @s is int the process of being required, prints warning message and returns false; should I reset vars.requiring? 
--@path (optional, defaults first to the caller environment REQUIRE_PATH, then to @vars.path)
--	e.g. '?;?.lua;APIS;user[1-9]/packages'
-- 	each string surrrounded by ';' must be a glob, which is a special kind of pattern, like Lua ones but simpler.
--	rules are the same as the ones defined in the unix part of the table at http://en.wikipedia.org/wiki/Glob_(programming)
--	WARNING in this glob each '?' (the wildcard that matches one character is now # instead of ?) is replaced by @s
--	(after transforming '.' in '/')
--	e.g require('A.B.c','E/?') would result in the glob E/A/B/c 
-- 	@s and @path are passed to the functions in @vars.loaders, which must return a function, path_of_file in case of success or string describing the reason of failure;
--	default are:
--		@loadGlob: uses the globs generated to iterate efficiently over the filesystem and filter the right paths
--		(meaning it doesn't go through all available paths) from which it attempts to load.
--		@loadSearch: filters the globs that are normal paths, and searches their entire directory trees
--		for a file whose name (extension ripped off) matches the last section of @s, e.g. s='aaa.g'
--		would mean looking for g or g.(whatever).
--environments: sets the function loaded from file env's to @env (default is the caler's env) and the metatable of @env to {__index=@renv} 
--@... args to be passed to the loaded function

function lua_requirer(path,cenv,env,renv,args)
	if vars.requiring[path] then
		return nil, s..' in path '..path..' is being loaded'
	elseif vars.required[path] then
		return vars.required[path]
	end
	
	local f,e=loadfile(path)
	if not f then
		return nil,'path='..path..'|lua_requirer:loadfile:'..e
	end
	env=env or {}
	env.FILE_PATH=path
	vars.required_envs[path]=env
	setfenv(f,env)
	renv=renv or _G
	setmetatable(env,{__index=renv})
	vars.requiring[path]=true
	local r=f(args and unpack(args)) --raises useful error/traceback, no need to tamper with
	vars.requiring[path]=nil
	if r then
		vars.required[path]=r
		return r
	else
		local t={}
		for i,v in pairs(env) do t[i]=v end
		vars.required[path]=t
		return t
	end
end

old_os_loadAPI=os.loadAPI
new_os_loadAPI=function(p)
	local cenv=getfenv(2)
	local r,e=loadreq.lua_requirer(p,cenv)
	if r then
		local name=getNameExpansion(p)
		protect(r)
		cenv[p]=r
	else
		error('os.loadAPI(loadreq version):'..e..'\n'..'path='..p,2)
	end
end

vars.requirers={lua_requirer}

function sufix(s)
	return string.gsub('@/?;@/?.lua;@/?/init.lua;@/?/?.lua;@/?/?;@','@',s)
end

function require(s,paths,...)--same behavior as Lua require, with the extra of @path, if not nil replacing @vars.path
	local caller_env=getfenv(2)
	if paths then
	elseif caller_env.REQUIRE_PATH then
		paths=caller_env.REQUIRE_PATH
	elseif caller_env.PACKAGE_NAME and caller_env.FILE_PATH then
		paths=sufix(string.match(caller_env.FILE_PATH,'^(.*'..caller_env.PACKAGE_NAME..')'))..';'..vars.paths
	elseif	caller_env.FILE_PATH then
		paths=getDir(caller_env.FILE_PATH)..';'..vars.paths
	else
		paths=vars.paths
	end
	
	--replace . by / and .. by . 
	s=string.gsub(s,'([^%.])%.([^%.])','%1/%2') 
	s=string.gsub(s,'^%.([^%.])','/%1')
	s=string.gsub(s,'%.%.','.')
	local err={}
	for _,finder in ipairs(vars.finders) do
		for search_path in string.gmatch(paths,';?([^;]*);?') do
			--print(search_path)
			for path in finder(search_path,s) do
				--print(path)
				for __,requirer in ipairs(vars.requirers) do
					--print(path)
					local r,e=requirer(path,caller_env,...)
					if r then
						return r
					else
						table.insert(err,e)
					end
				end
			end
		end
	end
	table.insert(err,'require:file not found:'..s..'\npaths='..paths..'\ncaller path='..(caller_env.FILE_PATH or 'not available'))
	error(table.concat(err,'\n'),2)
end

--utilities
function set_env(f,env,renv)--sets @f 's env to @env (default new table {}) and the metatable of @env to {__index=@renv (default _G)}
	local env = env or {}
	local renv = renv or _G
	setmetatable( env, { __index = renv } )
	setfenv( f, env )
end

function str(s,env,renv) --loads string @s setting it's env to @env (default is the caler's env) and the metatable of @env to {__index=@renv}
	local f, err = loadstring( s )
	if not f then error( 'loadreq.str:'..(err or 'nil') ,2) end
	set_env(f,env or getfenv(2),renv)
	return f
end

function file(p,env,renv) --(re)loads file in path @p setting it's env to @env and the metatable of @env to {__index=@renv}
	f=loadfile(p)
	if not f then error('file',2) end
	env=env or {}
	env.FILE_PATH=p
	set_env(f,env,renv)
	return f
end

function run(p,args,env,renv)--runs file in path @p and unpacks @args to get arguments for the file; sets it's env to @env (default is the caler's env) and the metatable of @env to {__index=@renv}
	f=file(p,env,renv)
	args=args or {}
	return f(unpack(args))
end

--protection utilities; these are meant more as a warning than OS-grade protection
vars.bProtected=true
local function protected_access(t,k,v)
	if vars.bProtected then
		error( "Attempt to write to protected" )
	else
		rawset( t, k, v )
	end
end
function protect(_t)--shallow protection for tables (slows down access to the tables themselves, not to their values, e.g. local t.a=protected_table.a print(a) should do the trick)
	local meta = getmetatable( _t )
	if meta == "Protected" then
		-- already hard protected
		return
	end
	if meta then
		meta.__newindex = protected_access
	else
		setmetatable( _t, {__newindex = protected_access} )
	end
end
function unprotect(_t)--removes the shallow protection
	local meta = getmetatable( _t )
	if not meta then
		return
	end
	vars.bProtected=false
	meta.__newindex=nil
	vars.bProtected=true
end

function permaProtect(_t) --same as the os.loadAPI does
	local meta = getmetatable( _t )
	if meta == "Protected" then
		-- already hard protected
		return
	end
	setmetatable( _t, {
		__newindex = function( t, k, v )
			if bProtected then
				error( "Attempt to write to protected" )
			else
				rawset( t, k, v )
			end
		end,
		__metatable = 'Protected',
	} )
end

--module utilities

function module(M) --copies env of the caller to table @M (default {}) and returns it
	M=M or {}
	for i,v in getfenv(2) do
		M[i]=v
	end
	return M
end


--compatibility for os.loadAPI
env=getfenv() --this keeps the env from being collected to garbage?
