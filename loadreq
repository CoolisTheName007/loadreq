---require implementation in pure Lua for a sandbox environment, with support for globs and full directory tree search.
--Licensed under the MIT license, whatever that is.


local fs=fs
local string=string
local loadfile=loadfile
local error=error

local log,search


local function getNameExpansion(s) --returns name and expansion from a filepath @s; special cases: ''->'',nil; '.'-> '','';
	local _,_,name,expa=string.find(s, '([^%./\\]*)%.(.*)$')
	return name or s,expa
end

function getDir(s) --returns directory from filepath @s
	return string.match(s,'^(.*)/') or '/'
end

vars={} --to allow edition
vars.loaded={}
function loadFile(path,_reload) --@_reload forces reload
	if (vars.loaded[path]==nil) or _reload then
		local fnFile, err = loadfile( path )
		if not fnFile then error('load:'..'path=:'..path..'| '..(err or 'nil'),2) end
		vars.loaded[path]=fnFile
	end
	return vars.loaded[path]
end

local function direct(g,s)
	g=string.gsub(g,'%?',s)
	return function()
		if g and fs.exists(g) and not fs.isDir(g) then local a=g g=nil return a end
	end
end
--add your iterators here; must take (p,s) where p is where to search and s is what to search for.
vars.finders={direct}
vars.paths='?;?.lua;?/init.lua;APIS/?;APIS/?.lua;APIS/?/init.lua;packages/?;packages/?.lua;packages/?/init.lua;packages/?/?;packages/?/?.lua;/'

--helper vars for lua_requirer; other requirers may index theirs vars in loadreq.vars
vars.lua_requirer={
required={}, --to unrequire filepath s do require[s]=nil
required_envs={}, --to prevent garbage collection
requiring={}, --to throw error in case of recursive requiring;
}

--[[lua_requirer(path,cenv,env,renv,rerun,args)
if the rerun flag is true, reloads the file even if it done it before
only requires files with no extension
if the file has been loaded already returns previous value;
if the file is being loaded returns nil, error_message
else:
loads file in @path;
sets it's env to @env, default {} with metatable with __index set to @renv, default _G;
calls the function with unpack(@args) and returns and saves either
	the function return
	a shallow copy of the functions environment
]]

function lua_requirer(path,cenv,env,renv,rerun,args)
	local err_prefix='lua_requirer:'
	local vars=vars.lua_requirer
	local _,ext=getNameExpansion(path)
	if not (ext=='' or ext=='lua' or ext==nil) then
		return nil, err_prefix..'wrong extension:'..ext
	end
	
	if vars.requiring[path] then
		return nil, err_prefix..'file is being loaded'
	end
	if not rerun and vars.required[path] then
		return vars.required[path]
	end
	
	local f,e=loadfile(path)
	if not f then
		return nil,err_prefix..'loadfile:'..e
	end
	env=env or {}
	env.FILE_PATH=path
	vars.required_envs[path]=env
	setfenv(f,env)
	renv=renv or _G
	setmetatable(env,{__index=renv})
	vars.requiring[path]=true
	local r=f(args and unpack(args)) --raises useful error/traceback, no need to tamper with
	vars.requiring[path]=nil
	if r then
		vars.required[path]=r
		return r
	else
		local t={}
		for i,v in pairs(env) do t[i]=v end
		vars.required[path]=t
		return t
	end
end

--replacement for os_loadAPI that keeps APIS to the caller's env
old_os_loadAPI=os.loadAPI
new_os_loadAPI=function(p)
	local cenv=getfenv(2)
	local r,e=loadreq.lua_requirer(p,cenv)
	if r then
		local name=getNameExpansion(p)
		protect(r)
		cenv[p]=r
	else
		error('os.loadAPI(loadreq version):'..e..'\n'..'path='..p,2)
	end
end

--[[add your requirers here;
each must 
take as arguments (path,cenv,...) where
	path is the path to required file
	cenv is the environment of the caller of @require
	... are extra arguments passed to @require
return
	one value to be returned by @require
	false|nil, error_message in case of failure
]]
vars.requirers={lua=lua_requirer}

function sufix(s)
	return string.gsub('@/?;@/?.lua;@/?/init.lua;@/?/?.lua;@/?/?;@','@',s)
end

--[[require(s,paths,...)
-acquires @paths variable;
	@paths is a string, made of globs separated by ';'
	globs can be normal paths or contain special characters ('?' and others ('?' was replaced by '#') as described here: see the unix part of the table at http://en.wikipedia.org/wiki/Glob_(programming))
defaults to:
	0-arg @paths
		Example:
		myAPI=require('myFolder2.myAPI','myFolder/?.lua') 
	1-REQUIRE_PATH in the caller's path, if existent
		Example:
		REQUIRE_PATH='myFolder/?.lua'
		myAPI=require'myFolder2.myAPI' 
	2-directory named PACKAGE_NAME in FILE_PATH, if defined in the caller's environment
	with sufixes appended by @sufix and concatenated with @vars.paths.
	FILE_PATH is set, for instance, by lua_loader in the files it loads.
		Example:
		(FILE_PATH='myFolder/myFolder3/myFolder/runningFile')
		PACKAGE_NAME='myFolder'
		myAPI=require'myAPI' --@paths is 'myFolder/?;myFolder/?.lua;myFolder/?/init.lua;myFolder/?/?.lua;myFolder/?/?;myFolder'
	3-directory of FILE_PATH, if defined
	with sufixes appended by @sufix and concatenated with @vars.paths.
		Example:
		(FILE_PATH='myFolder/runningFile')
		myAPI=require'myAPI' --@paths is 'myFolder/?;myFolder/?.lua;myFolder/?/init.lua;myFolder/?/?.lua;myFolder/?/?;myFolder'
	4-@vars.paths as set in loadreq.vars.path
-replaces '.' in @s by '/' and '..' by '.'
--for all globs in @paths
 -	for all iterators in vars.finders iterates over the paths returned;
	default iterators:
		searchGlob: replaces '?' in the glob by @s paths and iterates over the filepaths that match the glob
		searchTree: only for globs that are directory paths: paths that are in the directory tree of glob		
-for the first valid path, calls the loaders sequentially until one succeds, 
in which case it returns the first value that the loader returns, else if it returns nil,e accumulates e as an error message
else if all loaders fail errors immediatly, printing all error messages
-in case of failure finding the path, errors with useful info
]]

function require(s,paths,...)
	if log then log('loadreq','INFO','require: requiring %s',s) end
	local caller_env=getfenv(2)
	if paths then
	elseif caller_env.REQUIRE_PATH then
		paths=caller_env.REQUIRE_PATH
	elseif caller_env.PACKAGE_NAME and caller_env.FILE_PATH then
		paths=sufix(string.match(caller_env.FILE_PATH,'^(.*'..caller_env.PACKAGE_NAME..')'))..';'..vars.paths
	elseif	caller_env.FILE_PATH then
		paths=sufix(getDir(caller_env.FILE_PATH))..';'..vars.paths
	else
		paths=vars.paths
	end
	
	--replace . by / and .. by . 
	s=string.gsub(s,'([^%.])%.([^%.])','%1/%2') 
	s=string.gsub(s,'^%.([^%.])','/%1')
	s=string.gsub(s,'%.%.','.')
	
	-- print(s)
	local err={}
	local finders=vars.finders
	
	local finder
	for i=1,#finders do
		finder=finders[i]
		for search_path in string.gmatch(paths,';?([^;]+);?') do
			for path in finder(search_path,s) do
				table.insert(err,'path='..path)
				
				for req_name,requirer in pairs(vars.requirers) do
					local r,e=requirer(path,caller_env,...)
					if r then
						if log then log('loadreq','INFO','require: success in requiring %s;requirer=%s; path=%s',s,req_name,path) end
						return r
					else
						table.insert(err,e)
					end
				end
				
				local serr=table.concat(err,'\n')
				if log then log('loadreq','ERROR','require:%s',serr) end
				error(serr,2) --this path can't be loaded, and yet it is a similar file? consider specifying path more or fixing bugs!
			end
		end
	end
	table.insert(err,'require:file not found:'..s..'\npaths='..paths..'\ncaller path='..(caller_env.FILE_PATH or 'not available'))
	local serr=table.concat(err,'\n')
	if log then log('loadreq','ERROR','require:%s',serr) end
	error(serr,2)
	
end

---runs filepath path with args ... using the same rules as @require for determining the globs to uses
--e.g.
--[[
os.loadAPI('APIS/loadreq')
loadreq.vars.paths=loadreq.vars.paths..';myFolder'
--or
REQUIRE_PATH='myFolder'
--ect
loadreq.run_lua('subFolder/subsubFolder/myFile.lua',arg1,arg2,...)
]]
function run_lua(path,...)
	if type(path)~='string' then error('loadreq.run_lua:not a string:',path) end
	path=path:gsub('%.','..')
	path=path:gsub('%/','.')
	return require(path,nil,nil,nil,true,{...})
end


--utilities
function set_env(f,env,renv)--sets @f 's env to @env (default new table {}) and the metatable of @env to {__index=@renv (default _G)}
	local env = env or {}
	local renv = renv or _G
	setmetatable( env, { __index = renv } )
	setfenv( f, env )
end

function str(s,env,renv) --loads string @s setting it's env to @env (default is the caler's env) and the metatable of @env to {__index=@renv}
	local f, err = loadstring( s )
	if not f then error( 'loadreq.str:'..(err or 'nil') ,2) end
	set_env(f,env or getfenv(2),renv)
	return f
end

function file(p,env,renv) --(re)loads file in path @p setting it's env to @env and the metatable of @env to {__index=@renv}
	f=loadfile(p)
	if not f then error('file',2) end
	env=env or {}
	env.FILE_PATH=p
	set_env(f,env,renv)
	return f
end

function run(p,args,env,renv)--runs file in path @p and unpacks @args to get arguments for the file; sets it's env to @env (default is the caler's env) and the metatable of @env to {__index=@renv}
	f=file(p,env,renv)
	args=args or {}
	return f(unpack(args))
end

--protection utilities; these are meant more as a warning than OS-grade protection
vars.bProtected=true
local function protected_access(t,k,v)
	if vars.bProtected then
		error( "Attempt to write to protected" )
	else
		rawset( t, k, v )
	end
end
function protect(_t)--shallow protection for tables (slows down access to the tables themselves, not to their values, e.g. local t.a=protected_table.a print(a) should do the trick)
	local meta = getmetatable( _t )
	if meta == "Protected" then
		-- already hard protected
		return
	end
	if meta then
		meta.__newindex = protected_access
	else
		setmetatable( _t, {__newindex = protected_access} )
	end
end
function unprotect(_t)--removes the shallow protection
	local meta = getmetatable( _t )
	if not meta then
		return
	end
	vars.bProtected=false
	meta.__newindex=nil
	vars.bProtected=true
end

function permaProtect(_t) --same as the os.loadAPI does
	local meta = getmetatable( _t )
	if meta == "Protected" then
		-- already hard protected
		return
	end
	setmetatable( _t, {
		__newindex = function( t, k, v )
			if bProtected then
				error( "Attempt to write to protected" )
			else
				rawset( t, k, v )
			end
		end,
		__metatable = 'Protected',
	} )
end

--module utilities

function module(M) --copies env of the caller to table @M (default {}) and returns it
	M=M or {}
	for i,v in getfenv(2) do
		M[i]=v
	end
	return M
end


--Platform dependant code here
if fs.exists('packages/log/init.lua') then
	rawset(_G,'require',require)
	log=require'packages.log.init..lua'
	search=require'packages.search.init..lua'
	vars.finders={}
	table.insert(vars.finders,search.searchGlob)
	table.insert(vars.finders,search.searchTree)
end

env=getfenv() --this keeps the env from being collected to garbage
